{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\medin\\\\Documents\\\\Universidad\\\\portfolio-8bit\\\\src\\\\components\\\\PixelBlast.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\nimport { EffectComposer, EffectPass, RenderPass, Effect } from 'postprocessing';\nimport '../styles/PixelBlast.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst createTouchTexture = () => {\n  const size = 64;\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new Error('2D context not available');\n  ctx.fillStyle = 'black';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  const texture = new THREE.Texture(canvas);\n  texture.minFilter = THREE.LinearFilter;\n  texture.magFilter = THREE.LinearFilter;\n  texture.generateMipmaps = false;\n  const trail = [];\n  let last = null;\n  const maxAge = 64;\n  let radius = 0.1 * size;\n  const speed = 1 / maxAge;\n  const clear = () => {\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n  };\n  const drawPoint = p => {\n    const pos = {\n      x: p.x * size,\n      y: (1 - p.y) * size\n    };\n    let intensity = 1;\n    const easeOutSine = t => Math.sin(t * Math.PI / 2);\n    const easeOutQuad = t => -t * (t - 2);\n    if (p.age < maxAge * 0.3) intensity = easeOutSine(p.age / (maxAge * 0.3));else intensity = easeOutQuad(1 - (p.age - maxAge * 0.3) / (maxAge * 0.7)) || 0;\n    intensity *= p.force;\n    const color = `${(p.vx + 1) / 2 * 255}, ${(p.vy + 1) / 2 * 255}, ${intensity * 255}`;\n    const offset = size * 5;\n    ctx.shadowOffsetX = offset;\n    ctx.shadowOffsetY = offset;\n    ctx.shadowBlur = radius;\n    ctx.shadowColor = `rgba(${color},${0.22 * intensity})`;\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(255,0,0,1)';\n    ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);\n    ctx.fill();\n  };\n  const addTouch = norm => {\n    let force = 0;\n    let vx = 0;\n    let vy = 0;\n    if (last) {\n      const dx = norm.x - last.x;\n      const dy = norm.y - last.y;\n      if (dx === 0 && dy === 0) return;\n      const dd = dx * dx + dy * dy;\n      const d = Math.sqrt(dd);\n      vx = dx / (d || 1);\n      vy = dy / (d || 1);\n      force = Math.min(dd * 10000, 1);\n    }\n    last = {\n      x: norm.x,\n      y: norm.y\n    };\n    trail.push({\n      x: norm.x,\n      y: norm.y,\n      age: 0,\n      force,\n      vx,\n      vy\n    });\n  };\n  const update = () => {\n    clear();\n    for (let i = trail.length - 1; i >= 0; i--) {\n      const point = trail[i];\n      const f = point.force * speed * (1 - point.age / maxAge);\n      point.x += point.vx * f;\n      point.y += point.vy * f;\n      point.age++;\n      if (point.age > maxAge) trail.splice(i, 1);\n    }\n    for (let i = 0; i < trail.length; i++) drawPoint(trail[i]);\n    texture.needsUpdate = true;\n  };\n  return {\n    canvas,\n    texture,\n    addTouch,\n    update,\n    set radiusScale(v) {\n      radius = 0.1 * size * v;\n    },\n    get radiusScale() {\n      return radius / (0.1 * size);\n    },\n    size\n  };\n};\nconst createLiquidEffect = (texture, opts) => {\n  var _opts$strength, _opts$freq;\n  const fragment = `\n    uniform sampler2D uTexture;\n    uniform float uStrength;\n    uniform float uTime;\n    uniform float uFreq;\n\n    void mainUv(inout vec2 uv) {\n      vec4 tex = texture2D(uTexture, uv);\n      float vx = tex.r * 2.0 - 1.0;\n      float vy = tex.g * 2.0 - 1.0;\n      float intensity = tex.b;\n\n      float wave = 0.5 + 0.5 * sin(uTime * uFreq + intensity * 6.2831853);\n\n      float amt = uStrength * intensity * wave;\n\n      uv += vec2(vx, vy) * amt;\n    }\n    `;\n  return new Effect('LiquidEffect', fragment, {\n    uniforms: new Map([['uTexture', new THREE.Uniform(texture)], ['uStrength', new THREE.Uniform((_opts$strength = opts === null || opts === void 0 ? void 0 : opts.strength) !== null && _opts$strength !== void 0 ? _opts$strength : 0.025)], ['uTime', new THREE.Uniform(0)], ['uFreq', new THREE.Uniform((_opts$freq = opts === null || opts === void 0 ? void 0 : opts.freq) !== null && _opts$freq !== void 0 ? _opts$freq : 4.5)]])\n  });\n};\nconst SHAPE_MAP = {\n  square: 0,\n  circle: 1,\n  triangle: 2,\n  diamond: 3\n};\nconst VERTEX_SRC = `\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n`;\nconst FRAGMENT_SRC = `\nprecision highp float;\n\nuniform vec3  uColor;\nuniform vec2  uResolution;\nuniform float uTime;\nuniform float uPixelSize;\nuniform float uScale;\nuniform float uDensity;\nuniform float uPixelJitter;\nuniform int   uEnableRipples;\nuniform float uRippleSpeed;\nuniform float uRippleThickness;\nuniform float uRippleIntensity;\nuniform float uEdgeFade;\n\nuniform int   uShapeType;\nconst int SHAPE_SQUARE   = 0;\nconst int SHAPE_CIRCLE   = 1;\nconst int SHAPE_TRIANGLE = 2;\nconst int SHAPE_DIAMOND  = 3;\n\nconst int   MAX_CLICKS = 10;\n\nuniform vec2  uClickPos  [MAX_CLICKS];\nuniform float uClickTimes[MAX_CLICKS];\n\nout vec4 fragColor;\n\nfloat Bayer2(vec2 a) {\n  a = floor(a);\n  return fract(a.x / 2. + a.y * a.y * .75);\n}\n#define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))\n#define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))\n\n#define FBM_OCTAVES     5\n#define FBM_LACUNARITY  1.25\n#define FBM_GAIN        1.0\n\nfloat hash11(float n){ return fract(sin(n)*43758.5453); }\n\nfloat vnoise(vec3 p){\n  vec3 ip = floor(p);\n  vec3 fp = fract(p);\n  float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));\n  float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));\n  float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));\n  float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));\n  float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));\n  float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));\n  float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));\n  float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));\n  vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);\n  float x00 = mix(n000, n100, w.x);\n  float x10 = mix(n010, n110, w.x);\n  float x01 = mix(n001, n101, w.x);\n  float x11 = mix(n011, n111, w.x);\n  float y0  = mix(x00, x10, w.y);\n  float y1  = mix(x01, x11, w.y);\n  return mix(y0, y1, w.z) * 2.0 - 1.0;\n}\n\nfloat fbm2(vec2 uv, float t){\n  vec3 p = vec3(uv * uScale, t);\n  float amp = 1.0;\n  float freq = 1.0;\n  float sum = 1.0;\n  for (int i = 0; i < FBM_OCTAVES; ++i){\n    sum  += amp * vnoise(p * freq);\n    freq *= FBM_LACUNARITY;\n    amp  *= FBM_GAIN;\n  }\n  return sum * 0.5 + 0.5;\n}\n\nfloat maskCircle(vec2 p, float cov){\n  float r = sqrt(cov) * .25;\n  float d = length(p - 0.5) - r;\n  float aa = 0.5 * fwidth(d);\n  return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));\n}\n\nfloat maskTriangle(vec2 p, vec2 id, float cov){\n  bool flip = mod(id.x + id.y, 2.0) > 0.5;\n  if (flip) p.x = 1.0 - p.x;\n  float r = sqrt(cov);\n  float d  = p.y - r*(1.0 - p.x);\n  float aa = fwidth(d);\n  return cov * clamp(0.5 - d/aa, 0.0, 1.0);\n}\n\nfloat maskDiamond(vec2 p, float cov){\n  float r = sqrt(cov) * 0.564;\n  return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);\n}\n\nvoid main(){\n  float pixelSize = uPixelSize;\n  vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;\n  float aspectRatio = uResolution.x / uResolution.y;\n\n  vec2 pixelId = floor(fragCoord / pixelSize);\n  vec2 pixelUV = fract(fragCoord / pixelSize);\n\n  float cellPixelSize = 8.0 * pixelSize;\n  vec2 cellId = floor(fragCoord / cellPixelSize);\n  vec2 cellCoord = cellId * cellPixelSize;\n  vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);\n\n  float base = fbm2(uv, uTime * 0.05);\n  base = base * 0.5 - 0.65;\n\n  float feed = base + (uDensity - 0.5) * 0.3;\n\n  float speed     = uRippleSpeed;\n  float thickness = uRippleThickness;\n  const float dampT     = 1.0;\n  const float dampR     = 10.0;\n\n  if (uEnableRipples == 1) {\n    for (int i = 0; i < MAX_CLICKS; ++i){\n      vec2 pos = uClickPos[i];\n      if (pos.x < 0.0) continue;\n      float cellPixelSize = 8.0 * pixelSize;\n      vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution))) * vec2(aspectRatio, 1.0);\n      float t = max(uTime - uClickTimes[i], 0.0);\n      float r = distance(uv, cuv);\n      float waveR = speed * t;\n      float ring  = exp(-pow((r - waveR) / thickness, 2.0));\n      float atten = exp(-dampT * t) * exp(-dampR * r);\n      feed = max(feed, ring * atten * uRippleIntensity);\n    }\n  }\n\n  float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;\n  float bw = step(0.5, feed + bayer);\n\n  float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);\n  float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;\n  float coverage = bw * jitterScale;\n  float M;\n  if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);\n  else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);\n  else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);\n  else                                   M = coverage;\n\n  if (uEdgeFade > 0.0) {\n    vec2 norm = gl_FragCoord.xy / uResolution;\n    float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));\n    float fade = smoothstep(0.0, uEdgeFade, edge);\n    M *= fade;\n  }\n\n  vec3 color = uColor;\n  fragColor = vec4(color, M);\n}\n`;\nconst MAX_CLICKS = 10;\nconst PixelBlast = ({\n  variant = 'square',\n  pixelSize = 3,\n  color = '#B19EEF',\n  className,\n  style,\n  antialias = true,\n  patternScale = 2,\n  patternDensity = 1,\n  liquid = false,\n  liquidStrength = 0.1,\n  liquidRadius = 1,\n  pixelSizeJitter = 0,\n  enableRipples = true,\n  rippleIntensityScale = 1,\n  rippleThickness = 0.1,\n  rippleSpeed = 0.3,\n  liquidWobbleSpeed = 4.5,\n  autoPauseOffscreen = true,\n  speed = 0.5,\n  transparent = true,\n  edgeFade = 0.5,\n  noiseAmount = 0\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const visibilityRef = useRef({\n    visible: true\n  });\n  const speedRef = useRef(speed);\n  const threeRef = useRef(null);\n  const prevConfigRef = useRef(null);\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    speedRef.current = speed;\n    const needsReinitKeys = ['antialias', 'liquid', 'noiseAmount'];\n    const cfg = {\n      antialias,\n      liquid,\n      noiseAmount\n    };\n    let mustReinit = false;\n    if (!threeRef.current) mustReinit = true;else if (prevConfigRef.current) {\n      for (const k of needsReinitKeys) if (prevConfigRef.current[k] !== cfg[k]) {\n        mustReinit = true;\n        break;\n      }\n    }\n    if (mustReinit) {\n      var _SHAPE_MAP$variant;\n      if (threeRef.current) {\n        var _t$resizeObserver, _t$quad, _t$composer;\n        const t = threeRef.current;\n        (_t$resizeObserver = t.resizeObserver) === null || _t$resizeObserver === void 0 ? void 0 : _t$resizeObserver.disconnect();\n        cancelAnimationFrame(t.raf);\n        (_t$quad = t.quad) === null || _t$quad === void 0 ? void 0 : _t$quad.geometry.dispose();\n        t.material.dispose();\n        (_t$composer = t.composer) === null || _t$composer === void 0 ? void 0 : _t$composer.dispose();\n        t.renderer.dispose();\n        if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\n        threeRef.current = null;\n      }\n      const canvas = document.createElement('canvas');\n      const renderer = new THREE.WebGLRenderer({\n        canvas,\n        antialias,\n        alpha: true,\n        powerPreference: 'high-performance'\n      });\n      renderer.domElement.style.width = '100%';\n      renderer.domElement.style.height = '100%';\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n      container.appendChild(renderer.domElement);\n      if (transparent) renderer.setClearAlpha(0);else renderer.setClearColor(0x000000, 1);\n      const uniforms = {\n        uResolution: {\n          value: new THREE.Vector2(0, 0)\n        },\n        uTime: {\n          value: 0\n        },\n        uColor: {\n          value: new THREE.Color(color)\n        },\n        uClickPos: {\n          value: Array.from({\n            length: MAX_CLICKS\n          }, () => new THREE.Vector2(-1, -1))\n        },\n        uClickTimes: {\n          value: new Float32Array(MAX_CLICKS)\n        },\n        uShapeType: {\n          value: (_SHAPE_MAP$variant = SHAPE_MAP[variant]) !== null && _SHAPE_MAP$variant !== void 0 ? _SHAPE_MAP$variant : 0\n        },\n        uPixelSize: {\n          value: pixelSize * renderer.getPixelRatio()\n        },\n        uScale: {\n          value: patternScale\n        },\n        uDensity: {\n          value: patternDensity\n        },\n        uPixelJitter: {\n          value: pixelSizeJitter\n        },\n        uEnableRipples: {\n          value: enableRipples ? 1 : 0\n        },\n        uRippleSpeed: {\n          value: rippleSpeed\n        },\n        uRippleThickness: {\n          value: rippleThickness\n        },\n        uRippleIntensity: {\n          value: rippleIntensityScale\n        },\n        uEdgeFade: {\n          value: edgeFade\n        }\n      };\n      const scene = new THREE.Scene();\n      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: VERTEX_SRC,\n        fragmentShader: FRAGMENT_SRC,\n        uniforms,\n        transparent: true,\n        depthTest: false,\n        depthWrite: false,\n        glslVersion: THREE.GLSL3\n      });\n      const quadGeom = new THREE.PlaneGeometry(2, 2);\n      const quad = new THREE.Mesh(quadGeom, material);\n      scene.add(quad);\n      const clock = new THREE.Clock();\n      const setSize = () => {\n        var _threeRef$current;\n        const w = container.clientWidth || 1;\n        const h = container.clientHeight || 1;\n        renderer.setSize(w, h, false);\n        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);\n        if ((_threeRef$current = threeRef.current) !== null && _threeRef$current !== void 0 && _threeRef$current.composer) threeRef.current.composer.setSize(renderer.domElement.width, renderer.domElement.height);\n        uniforms.uPixelSize.value = pixelSize * renderer.getPixelRatio();\n      };\n      setSize();\n      const ro = new ResizeObserver(setSize);\n      ro.observe(container);\n      const randomFloat = () => {\n        var _window$crypto;\n        if (typeof window !== 'undefined' && (_window$crypto = window.crypto) !== null && _window$crypto !== void 0 && _window$crypto.getRandomValues) {\n          const u32 = new Uint32Array(1);\n          window.crypto.getRandomValues(u32);\n          return u32[0] / 0xffffffff;\n        }\n        return Math.random();\n      };\n      const timeOffset = randomFloat() * 1000;\n      let composer;\n      let touch;\n      let liquidEffect;\n      if (liquid) {\n        touch = createTouchTexture();\n        touch.radiusScale = liquidRadius;\n        composer = new EffectComposer(renderer);\n        const renderPass = new RenderPass(scene, camera);\n        liquidEffect = createLiquidEffect(touch.texture, {\n          strength: liquidStrength,\n          freq: liquidWobbleSpeed\n        });\n        const effectPass = new EffectPass(camera, liquidEffect);\n        effectPass.renderToScreen = true;\n        composer.addPass(renderPass);\n        composer.addPass(effectPass);\n      }\n      if (noiseAmount > 0) {\n        if (!composer) {\n          composer = new EffectComposer(renderer);\n          composer.addPass(new RenderPass(scene, camera));\n        }\n        const noiseEffect = new Effect('NoiseEffect', `uniform float uTime; uniform float uAmount; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);} void mainUv(inout vec2 uv){} void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){ float n=hash(floor(uv*vec2(1920.0,1080.0))+floor(uTime*60.0)); float g=(n-0.5)*uAmount; outputColor=inputColor+vec4(vec3(g),0.0);} `, {\n          uniforms: new Map([['uTime', new THREE.Uniform(0)], ['uAmount', new THREE.Uniform(noiseAmount)]])\n        });\n        const noisePass = new EffectPass(camera, noiseEffect);\n        noisePass.renderToScreen = true;\n        if (composer && composer.passes.length > 0) {\n          composer.passes.forEach(p => {\n            const pass = p;\n            pass.renderToScreen = false;\n          });\n        }\n        composer.addPass(noisePass);\n      }\n      if (composer) composer.setSize(renderer.domElement.width, renderer.domElement.height);\n      const mapToPixels = e => {\n        const rect = renderer.domElement.getBoundingClientRect();\n        const scaleX = renderer.domElement.width / rect.width;\n        const scaleY = renderer.domElement.height / rect.height;\n        const fx = (e.clientX - rect.left) * scaleX;\n        const fy = (rect.height - (e.clientY - rect.top)) * scaleY;\n        return {\n          fx,\n          fy,\n          w: renderer.domElement.width,\n          h: renderer.domElement.height\n        };\n      };\n      const onPointerDown = e => {\n        var _threeRef$current$cli, _threeRef$current2;\n        const {\n          fx,\n          fy\n        } = mapToPixels(e);\n        const ix = (_threeRef$current$cli = (_threeRef$current2 = threeRef.current) === null || _threeRef$current2 === void 0 ? void 0 : _threeRef$current2.clickIx) !== null && _threeRef$current$cli !== void 0 ? _threeRef$current$cli : 0;\n        uniforms.uClickPos.value[ix].set(fx, fy);\n        uniforms.uClickTimes.value[ix] = uniforms.uTime.value;\n        if (threeRef.current) threeRef.current.clickIx = (ix + 1) % MAX_CLICKS;\n      };\n      const onPointerMove = e => {\n        if (!touch) return;\n        const {\n          fx,\n          fy,\n          w,\n          h\n        } = mapToPixels(e);\n        touch.addTouch({\n          x: fx / w,\n          y: fy / h\n        });\n      };\n      renderer.domElement.addEventListener('pointerdown', onPointerDown, {\n        passive: true\n      });\n      renderer.domElement.addEventListener('pointermove', onPointerMove, {\n        passive: true\n      });\n      let raf = 0;\n      const animate = () => {\n        if (autoPauseOffscreen && !visibilityRef.current.visible) {\n          raf = requestAnimationFrame(animate);\n          return;\n        }\n        uniforms.uTime.value = timeOffset + clock.getElapsedTime() * speedRef.current;\n        if (liquidEffect) {\n          const liqEffect = liquidEffect;\n          const timeUniform = liqEffect.uniforms.get('uTime');\n          if (timeUniform) timeUniform.value = uniforms.uTime.value;\n        }\n        if (composer) {\n          if (touch) touch.update();\n          composer.passes.forEach(p => {\n            const pass = p;\n            if (pass.effects) {\n              pass.effects.forEach(eff => {\n                var _eff$uniforms;\n                const timeUniform = (_eff$uniforms = eff.uniforms) === null || _eff$uniforms === void 0 ? void 0 : _eff$uniforms.get('uTime');\n                if (timeUniform) timeUniform.value = uniforms.uTime.value;\n              });\n            }\n          });\n          composer.render();\n        } else renderer.render(scene, camera);\n        raf = requestAnimationFrame(animate);\n      };\n      raf = requestAnimationFrame(animate);\n      threeRef.current = {\n        renderer,\n        scene,\n        camera,\n        material,\n        clock,\n        clickIx: 0,\n        uniforms,\n        resizeObserver: ro,\n        raf,\n        quad,\n        timeOffset,\n        composer,\n        touch,\n        liquidEffect\n      };\n    } else {\n      var _SHAPE_MAP$variant2;\n      const t = threeRef.current;\n      t.uniforms.uShapeType.value = (_SHAPE_MAP$variant2 = SHAPE_MAP[variant]) !== null && _SHAPE_MAP$variant2 !== void 0 ? _SHAPE_MAP$variant2 : 0;\n      t.uniforms.uPixelSize.value = pixelSize * t.renderer.getPixelRatio();\n      t.uniforms.uColor.value.set(color);\n      t.uniforms.uScale.value = patternScale;\n      t.uniforms.uDensity.value = patternDensity;\n      t.uniforms.uPixelJitter.value = pixelSizeJitter;\n      t.uniforms.uEnableRipples.value = enableRipples ? 1 : 0;\n      t.uniforms.uRippleIntensity.value = rippleIntensityScale;\n      t.uniforms.uRippleThickness.value = rippleThickness;\n      t.uniforms.uRippleSpeed.value = rippleSpeed;\n      t.uniforms.uEdgeFade.value = edgeFade;\n      if (transparent) t.renderer.setClearAlpha(0);else t.renderer.setClearColor(0x000000, 1);\n      if (t.liquidEffect) {\n        const liqEffect = t.liquidEffect;\n        const uStrength = liqEffect.uniforms.get('uStrength');\n        if (uStrength) uStrength.value = liquidStrength;\n        const uFreq = liqEffect.uniforms.get('uFreq');\n        if (uFreq) uFreq.value = liquidWobbleSpeed;\n      }\n      if (t.touch) t.touch.radiusScale = liquidRadius;\n    }\n    prevConfigRef.current = cfg;\n    return () => {\n      var _t$resizeObserver2, _t$quad2, _t$composer2;\n      if (threeRef.current && mustReinit) return;\n      if (!threeRef.current) return;\n      const t = threeRef.current;\n      (_t$resizeObserver2 = t.resizeObserver) === null || _t$resizeObserver2 === void 0 ? void 0 : _t$resizeObserver2.disconnect();\n      cancelAnimationFrame(t.raf);\n      (_t$quad2 = t.quad) === null || _t$quad2 === void 0 ? void 0 : _t$quad2.geometry.dispose();\n      t.material.dispose();\n      (_t$composer2 = t.composer) === null || _t$composer2 === void 0 ? void 0 : _t$composer2.dispose();\n      t.renderer.dispose();\n      if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\n      threeRef.current = null;\n    };\n  }, [antialias, liquid, noiseAmount, pixelSize, patternScale, patternDensity, enableRipples, rippleIntensityScale, rippleThickness, rippleSpeed, pixelSizeJitter, edgeFade, transparent, liquidStrength, liquidRadius, liquidWobbleSpeed, autoPauseOffscreen, variant, color, speed]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: `pixel-blast-container ${className !== null && className !== void 0 ? className : ''}`,\n    style: style,\n    \"aria-label\": \"PixelBlast interactive background\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 684,\n    columnNumber: 5\n  }, this);\n};\n_s(PixelBlast, \"4/F70/x0+L7nAfXxnp+Tig683DM=\");\n_c = PixelBlast;\nexport default PixelBlast;\nvar _c;\n$RefreshReg$(_c, \"PixelBlast\");","map":{"version":3,"names":["React","useEffect","useRef","THREE","EffectComposer","EffectPass","RenderPass","Effect","jsxDEV","_jsxDEV","createTouchTexture","size","canvas","document","createElement","width","height","ctx","getContext","Error","fillStyle","fillRect","texture","Texture","minFilter","LinearFilter","magFilter","generateMipmaps","trail","last","maxAge","radius","speed","clear","drawPoint","p","pos","x","y","intensity","easeOutSine","t","Math","sin","PI","easeOutQuad","age","force","color","vx","vy","offset","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","beginPath","arc","fill","addTouch","norm","dx","dy","dd","d","sqrt","min","push","update","i","length","point","f","splice","needsUpdate","radiusScale","v","createLiquidEffect","opts","_opts$strength","_opts$freq","fragment","uniforms","Map","Uniform","strength","freq","SHAPE_MAP","square","circle","triangle","diamond","VERTEX_SRC","FRAGMENT_SRC","MAX_CLICKS","PixelBlast","variant","pixelSize","className","style","antialias","patternScale","patternDensity","liquid","liquidStrength","liquidRadius","pixelSizeJitter","enableRipples","rippleIntensityScale","rippleThickness","rippleSpeed","liquidWobbleSpeed","autoPauseOffscreen","transparent","edgeFade","noiseAmount","_s","containerRef","visibilityRef","visible","speedRef","threeRef","prevConfigRef","container","current","needsReinitKeys","cfg","mustReinit","k","_SHAPE_MAP$variant","_t$resizeObserver","_t$quad","_t$composer","resizeObserver","disconnect","cancelAnimationFrame","raf","quad","geometry","dispose","material","composer","renderer","domElement","parentElement","removeChild","WebGLRenderer","alpha","powerPreference","setPixelRatio","window","devicePixelRatio","appendChild","setClearAlpha","setClearColor","uResolution","value","Vector2","uTime","uColor","Color","uClickPos","Array","from","uClickTimes","Float32Array","uShapeType","uPixelSize","getPixelRatio","uScale","uDensity","uPixelJitter","uEnableRipples","uRippleSpeed","uRippleThickness","uRippleIntensity","uEdgeFade","scene","Scene","camera","OrthographicCamera","ShaderMaterial","vertexShader","fragmentShader","depthTest","depthWrite","glslVersion","GLSL3","quadGeom","PlaneGeometry","Mesh","add","clock","Clock","setSize","_threeRef$current","w","clientWidth","h","clientHeight","set","ro","ResizeObserver","observe","randomFloat","_window$crypto","crypto","getRandomValues","u32","Uint32Array","random","timeOffset","touch","liquidEffect","renderPass","effectPass","renderToScreen","addPass","noiseEffect","noisePass","passes","forEach","pass","mapToPixels","e","rect","getBoundingClientRect","scaleX","scaleY","fx","clientX","left","fy","clientY","top","onPointerDown","_threeRef$current$cli","_threeRef$current2","ix","clickIx","onPointerMove","addEventListener","passive","animate","requestAnimationFrame","getElapsedTime","liqEffect","timeUniform","get","effects","eff","_eff$uniforms","render","_SHAPE_MAP$variant2","uStrength","uFreq","_t$resizeObserver2","_t$quad2","_t$composer2","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/medin/Documents/Universidad/portfolio-8bit/src/components/PixelBlast.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { EffectComposer, EffectPass, RenderPass, Effect } from 'postprocessing';\r\nimport '../styles/PixelBlast.css';\r\n\r\ntype PixelBlastVariant = 'square' | 'circle' | 'triangle' | 'diamond';\r\n\r\ninterface TouchPoint {\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n  force: number;\r\n  age: number;\r\n}\r\n\r\ninterface TouchTexture {\r\n  canvas: HTMLCanvasElement;\r\n  texture: THREE.Texture;\r\n  addTouch: (norm: { x: number; y: number }) => void;\r\n  update: () => void;\r\n  radiusScale: number;\r\n  size: number;\r\n}\r\n\r\ninterface ReinitConfig {\r\n  antialias: boolean;\r\n  liquid: boolean;\r\n  noiseAmount: number;\r\n}\r\n\r\ntype PixelBlastProps = {\r\n  variant?: PixelBlastVariant;\r\n  pixelSize?: number;\r\n  color?: string;\r\n  className?: string;\r\n  style?: React.CSSProperties;\r\n  antialias?: boolean;\r\n  patternScale?: number;\r\n  patternDensity?: number;\r\n  liquid?: boolean;\r\n  liquidStrength?: number;\r\n  liquidRadius?: number;\r\n  pixelSizeJitter?: number;\r\n  enableRipples?: boolean;\r\n  rippleIntensityScale?: number;\r\n  rippleThickness?: number;\r\n  rippleSpeed?: number;\r\n  liquidWobbleSpeed?: number;\r\n  autoPauseOffscreen?: boolean;\r\n  speed?: number;\r\n  transparent?: boolean;\r\n  edgeFade?: number;\r\n  noiseAmount?: number;\r\n};\r\n\r\nconst createTouchTexture = (): TouchTexture => {\r\n  const size = 64;\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = size;\r\n  canvas.height = size;\r\n  const ctx = canvas.getContext('2d');\r\n  if (!ctx) throw new Error('2D context not available');\r\n  ctx.fillStyle = 'black';\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  const texture = new THREE.Texture(canvas);\r\n  texture.minFilter = THREE.LinearFilter;\r\n  texture.magFilter = THREE.LinearFilter;\r\n  texture.generateMipmaps = false;\r\n  const trail: TouchPoint[] = [];\r\n  let last: { x: number; y: number } | null = null;\r\n  const maxAge = 64;\r\n  let radius = 0.1 * size;\r\n  const speed = 1 / maxAge;\r\n  const clear = () => {\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  };\r\n  const drawPoint = (p: TouchPoint) => {\r\n    const pos = { x: p.x * size, y: (1 - p.y) * size };\r\n    let intensity = 1;\r\n    const easeOutSine = (t: number) => Math.sin((t * Math.PI) / 2);\r\n    const easeOutQuad = (t: number) => -t * (t - 2);\r\n    if (p.age < maxAge * 0.3) intensity = easeOutSine(p.age / (maxAge * 0.3));\r\n    else intensity = easeOutQuad(1 - (p.age - maxAge * 0.3) / (maxAge * 0.7)) || 0;\r\n    intensity *= p.force;\r\n    const color = `${((p.vx + 1) / 2) * 255}, ${((p.vy + 1) / 2) * 255}, ${intensity * 255}`;\r\n    const offset = size * 5;\r\n    ctx.shadowOffsetX = offset;\r\n    ctx.shadowOffsetY = offset;\r\n    ctx.shadowBlur = radius;\r\n    ctx.shadowColor = `rgba(${color},${0.22 * intensity})`;\r\n    ctx.beginPath();\r\n    ctx.fillStyle = 'rgba(255,0,0,1)';\r\n    ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  };\r\n  const addTouch = (norm: { x: number; y: number }) => {\r\n    let force = 0;\r\n    let vx = 0;\r\n    let vy = 0;\r\n    if (last) {\r\n      const dx = norm.x - last.x;\r\n      const dy = norm.y - last.y;\r\n      if (dx === 0 && dy === 0) return;\r\n      const dd = dx * dx + dy * dy;\r\n      const d = Math.sqrt(dd);\r\n      vx = dx / (d || 1);\r\n      vy = dy / (d || 1);\r\n      force = Math.min(dd * 10000, 1);\r\n    }\r\n    last = { x: norm.x, y: norm.y };\r\n    trail.push({ x: norm.x, y: norm.y, age: 0, force, vx, vy });\r\n  };\r\n  const update = () => {\r\n    clear();\r\n    for (let i = trail.length - 1; i >= 0; i--) {\r\n      const point = trail[i];\r\n      const f = point.force * speed * (1 - point.age / maxAge);\r\n      point.x += point.vx * f;\r\n      point.y += point.vy * f;\r\n      point.age++;\r\n      if (point.age > maxAge) trail.splice(i, 1);\r\n    }\r\n    for (let i = 0; i < trail.length; i++) drawPoint(trail[i]);\r\n    texture.needsUpdate = true;\r\n  };\r\n  return {\r\n    canvas,\r\n    texture,\r\n    addTouch,\r\n    update,\r\n    set radiusScale(v: number) {\r\n      radius = 0.1 * size * v;\r\n    },\r\n    get radiusScale() {\r\n      return radius / (0.1 * size);\r\n    },\r\n    size\r\n  };\r\n};\r\n\r\nconst createLiquidEffect = (texture: THREE.Texture, opts?: { strength?: number; freq?: number }) => {\r\n  const fragment = `\r\n    uniform sampler2D uTexture;\r\n    uniform float uStrength;\r\n    uniform float uTime;\r\n    uniform float uFreq;\r\n\r\n    void mainUv(inout vec2 uv) {\r\n      vec4 tex = texture2D(uTexture, uv);\r\n      float vx = tex.r * 2.0 - 1.0;\r\n      float vy = tex.g * 2.0 - 1.0;\r\n      float intensity = tex.b;\r\n\r\n      float wave = 0.5 + 0.5 * sin(uTime * uFreq + intensity * 6.2831853);\r\n\r\n      float amt = uStrength * intensity * wave;\r\n\r\n      uv += vec2(vx, vy) * amt;\r\n    }\r\n    `;\r\n  return new Effect('LiquidEffect', fragment, {\r\n    uniforms: new Map<string, THREE.Uniform>([\r\n      ['uTexture', new THREE.Uniform(texture)],\r\n      ['uStrength', new THREE.Uniform(opts?.strength ?? 0.025)],\r\n      ['uTime', new THREE.Uniform(0)],\r\n      ['uFreq', new THREE.Uniform(opts?.freq ?? 4.5)]\r\n    ])\r\n  });\r\n};\r\n\r\nconst SHAPE_MAP: Record<PixelBlastVariant, number> = {\r\n  square: 0,\r\n  circle: 1,\r\n  triangle: 2,\r\n  diamond: 3\r\n};\r\n\r\nconst VERTEX_SRC = `\r\nvoid main() {\r\n  gl_Position = vec4(position, 1.0);\r\n}\r\n`;\r\n\r\nconst FRAGMENT_SRC = `\r\nprecision highp float;\r\n\r\nuniform vec3  uColor;\r\nuniform vec2  uResolution;\r\nuniform float uTime;\r\nuniform float uPixelSize;\r\nuniform float uScale;\r\nuniform float uDensity;\r\nuniform float uPixelJitter;\r\nuniform int   uEnableRipples;\r\nuniform float uRippleSpeed;\r\nuniform float uRippleThickness;\r\nuniform float uRippleIntensity;\r\nuniform float uEdgeFade;\r\n\r\nuniform int   uShapeType;\r\nconst int SHAPE_SQUARE   = 0;\r\nconst int SHAPE_CIRCLE   = 1;\r\nconst int SHAPE_TRIANGLE = 2;\r\nconst int SHAPE_DIAMOND  = 3;\r\n\r\nconst int   MAX_CLICKS = 10;\r\n\r\nuniform vec2  uClickPos  [MAX_CLICKS];\r\nuniform float uClickTimes[MAX_CLICKS];\r\n\r\nout vec4 fragColor;\r\n\r\nfloat Bayer2(vec2 a) {\r\n  a = floor(a);\r\n  return fract(a.x / 2. + a.y * a.y * .75);\r\n}\r\n#define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))\r\n#define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))\r\n\r\n#define FBM_OCTAVES     5\r\n#define FBM_LACUNARITY  1.25\r\n#define FBM_GAIN        1.0\r\n\r\nfloat hash11(float n){ return fract(sin(n)*43758.5453); }\r\n\r\nfloat vnoise(vec3 p){\r\n  vec3 ip = floor(p);\r\n  vec3 fp = fract(p);\r\n  float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));\r\n  float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));\r\n  float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));\r\n  float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));\r\n  vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);\r\n  float x00 = mix(n000, n100, w.x);\r\n  float x10 = mix(n010, n110, w.x);\r\n  float x01 = mix(n001, n101, w.x);\r\n  float x11 = mix(n011, n111, w.x);\r\n  float y0  = mix(x00, x10, w.y);\r\n  float y1  = mix(x01, x11, w.y);\r\n  return mix(y0, y1, w.z) * 2.0 - 1.0;\r\n}\r\n\r\nfloat fbm2(vec2 uv, float t){\r\n  vec3 p = vec3(uv * uScale, t);\r\n  float amp = 1.0;\r\n  float freq = 1.0;\r\n  float sum = 1.0;\r\n  for (int i = 0; i < FBM_OCTAVES; ++i){\r\n    sum  += amp * vnoise(p * freq);\r\n    freq *= FBM_LACUNARITY;\r\n    amp  *= FBM_GAIN;\r\n  }\r\n  return sum * 0.5 + 0.5;\r\n}\r\n\r\nfloat maskCircle(vec2 p, float cov){\r\n  float r = sqrt(cov) * .25;\r\n  float d = length(p - 0.5) - r;\r\n  float aa = 0.5 * fwidth(d);\r\n  return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));\r\n}\r\n\r\nfloat maskTriangle(vec2 p, vec2 id, float cov){\r\n  bool flip = mod(id.x + id.y, 2.0) > 0.5;\r\n  if (flip) p.x = 1.0 - p.x;\r\n  float r = sqrt(cov);\r\n  float d  = p.y - r*(1.0 - p.x);\r\n  float aa = fwidth(d);\r\n  return cov * clamp(0.5 - d/aa, 0.0, 1.0);\r\n}\r\n\r\nfloat maskDiamond(vec2 p, float cov){\r\n  float r = sqrt(cov) * 0.564;\r\n  return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);\r\n}\r\n\r\nvoid main(){\r\n  float pixelSize = uPixelSize;\r\n  vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;\r\n  float aspectRatio = uResolution.x / uResolution.y;\r\n\r\n  vec2 pixelId = floor(fragCoord / pixelSize);\r\n  vec2 pixelUV = fract(fragCoord / pixelSize);\r\n\r\n  float cellPixelSize = 8.0 * pixelSize;\r\n  vec2 cellId = floor(fragCoord / cellPixelSize);\r\n  vec2 cellCoord = cellId * cellPixelSize;\r\n  vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);\r\n\r\n  float base = fbm2(uv, uTime * 0.05);\r\n  base = base * 0.5 - 0.65;\r\n\r\n  float feed = base + (uDensity - 0.5) * 0.3;\r\n\r\n  float speed     = uRippleSpeed;\r\n  float thickness = uRippleThickness;\r\n  const float dampT     = 1.0;\r\n  const float dampR     = 10.0;\r\n\r\n  if (uEnableRipples == 1) {\r\n    for (int i = 0; i < MAX_CLICKS; ++i){\r\n      vec2 pos = uClickPos[i];\r\n      if (pos.x < 0.0) continue;\r\n      float cellPixelSize = 8.0 * pixelSize;\r\n      vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution))) * vec2(aspectRatio, 1.0);\r\n      float t = max(uTime - uClickTimes[i], 0.0);\r\n      float r = distance(uv, cuv);\r\n      float waveR = speed * t;\r\n      float ring  = exp(-pow((r - waveR) / thickness, 2.0));\r\n      float atten = exp(-dampT * t) * exp(-dampR * r);\r\n      feed = max(feed, ring * atten * uRippleIntensity);\r\n    }\r\n  }\r\n\r\n  float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;\r\n  float bw = step(0.5, feed + bayer);\r\n\r\n  float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);\r\n  float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;\r\n  float coverage = bw * jitterScale;\r\n  float M;\r\n  if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);\r\n  else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);\r\n  else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);\r\n  else                                   M = coverage;\r\n\r\n  if (uEdgeFade > 0.0) {\r\n    vec2 norm = gl_FragCoord.xy / uResolution;\r\n    float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));\r\n    float fade = smoothstep(0.0, uEdgeFade, edge);\r\n    M *= fade;\r\n  }\r\n\r\n  vec3 color = uColor;\r\n  fragColor = vec4(color, M);\r\n}\r\n`;\r\n\r\nconst MAX_CLICKS = 10;\r\n\r\nconst PixelBlast: React.FC<PixelBlastProps> = ({\r\n  variant = 'square',\r\n  pixelSize = 3,\r\n  color = '#B19EEF',\r\n  className,\r\n  style,\r\n  antialias = true,\r\n  patternScale = 2,\r\n  patternDensity = 1,\r\n  liquid = false,\r\n  liquidStrength = 0.1,\r\n  liquidRadius = 1,\r\n  pixelSizeJitter = 0,\r\n  enableRipples = true,\r\n  rippleIntensityScale = 1,\r\n  rippleThickness = 0.1,\r\n  rippleSpeed = 0.3,\r\n  liquidWobbleSpeed = 4.5,\r\n  autoPauseOffscreen = true,\r\n  speed = 0.5,\r\n  transparent = true,\r\n  edgeFade = 0.5,\r\n  noiseAmount = 0\r\n}) => {\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n  const visibilityRef = useRef({ visible: true });\r\n  const speedRef = useRef(speed);\r\n\r\n  const threeRef = useRef<{\r\n    renderer: THREE.WebGLRenderer;\r\n    scene: THREE.Scene;\r\n    camera: THREE.OrthographicCamera;\r\n    material: THREE.ShaderMaterial;\r\n    clock: THREE.Clock;\r\n    clickIx: number;\r\n    uniforms: {\r\n      uResolution: { value: THREE.Vector2 };\r\n      uTime: { value: number };\r\n      uColor: { value: THREE.Color };\r\n      uClickPos: { value: THREE.Vector2[] };\r\n      uClickTimes: { value: Float32Array };\r\n      uShapeType: { value: number };\r\n      uPixelSize: { value: number };\r\n      uScale: { value: number };\r\n      uDensity: { value: number };\r\n      uPixelJitter: { value: number };\r\n      uEnableRipples: { value: number };\r\n      uRippleSpeed: { value: number };\r\n      uRippleThickness: { value: number };\r\n      uRippleIntensity: { value: number };\r\n      uEdgeFade: { value: number };\r\n    };\r\n    resizeObserver?: ResizeObserver;\r\n    raf?: number;\r\n    quad?: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;\r\n    timeOffset?: number;\r\n    composer?: EffectComposer;\r\n    touch?: ReturnType<typeof createTouchTexture>;\r\n    liquidEffect?: Effect;\r\n  } | null>(null);\r\n  const prevConfigRef = useRef<ReinitConfig | null>(null);\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n    speedRef.current = speed;\r\n    const needsReinitKeys: (keyof ReinitConfig)[] = ['antialias', 'liquid', 'noiseAmount'];\r\n    const cfg: ReinitConfig = { antialias, liquid, noiseAmount };\r\n    let mustReinit = false;\r\n    if (!threeRef.current) mustReinit = true;\r\n    else if (prevConfigRef.current) {\r\n      for (const k of needsReinitKeys)\r\n        if (prevConfigRef.current[k] !== cfg[k]) {\r\n          mustReinit = true;\r\n          break;\r\n        }\r\n    }\r\n    if (mustReinit) {\r\n      if (threeRef.current) {\r\n        const t = threeRef.current;\r\n        t.resizeObserver?.disconnect();\r\n        cancelAnimationFrame(t.raf!);\r\n        t.quad?.geometry.dispose();\r\n        t.material.dispose();\r\n        t.composer?.dispose();\r\n        t.renderer.dispose();\r\n        if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\r\n        threeRef.current = null;\r\n      }\r\n      const canvas = document.createElement('canvas');\r\n      const renderer = new THREE.WebGLRenderer({\r\n        canvas,\r\n        antialias,\r\n        alpha: true,\r\n        powerPreference: 'high-performance'\r\n      });\r\n      renderer.domElement.style.width = '100%';\r\n      renderer.domElement.style.height = '100%';\r\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\r\n      container.appendChild(renderer.domElement);\r\n      if (transparent) renderer.setClearAlpha(0);\r\n      else renderer.setClearColor(0x000000, 1);\r\n      const uniforms = {\r\n        uResolution: { value: new THREE.Vector2(0, 0) },\r\n        uTime: { value: 0 },\r\n        uColor: { value: new THREE.Color(color) },\r\n        uClickPos: {\r\n          value: Array.from({ length: MAX_CLICKS }, () => new THREE.Vector2(-1, -1))\r\n        },\r\n        uClickTimes: { value: new Float32Array(MAX_CLICKS) },\r\n        uShapeType: { value: SHAPE_MAP[variant] ?? 0 },\r\n        uPixelSize: { value: pixelSize * renderer.getPixelRatio() },\r\n        uScale: { value: patternScale },\r\n        uDensity: { value: patternDensity },\r\n        uPixelJitter: { value: pixelSizeJitter },\r\n        uEnableRipples: { value: enableRipples ? 1 : 0 },\r\n        uRippleSpeed: { value: rippleSpeed },\r\n        uRippleThickness: { value: rippleThickness },\r\n        uRippleIntensity: { value: rippleIntensityScale },\r\n        uEdgeFade: { value: edgeFade }\r\n      };\r\n      const scene = new THREE.Scene();\r\n      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n      const material = new THREE.ShaderMaterial({\r\n        vertexShader: VERTEX_SRC,\r\n        fragmentShader: FRAGMENT_SRC,\r\n        uniforms,\r\n        transparent: true,\r\n        depthTest: false,\r\n        depthWrite: false,\r\n        glslVersion: THREE.GLSL3\r\n      });\r\n\r\n      const quadGeom = new THREE.PlaneGeometry(2, 2);\r\n      const quad = new THREE.Mesh(quadGeom, material);\r\n      scene.add(quad);\r\n      const clock = new THREE.Clock();\r\n      const setSize = () => {\r\n        const w = container.clientWidth || 1;\r\n        const h = container.clientHeight || 1;\r\n        renderer.setSize(w, h, false);\r\n        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);\r\n        if (threeRef.current?.composer)\r\n          threeRef.current.composer.setSize(renderer.domElement.width, renderer.domElement.height);\r\n        uniforms.uPixelSize.value = pixelSize * renderer.getPixelRatio();\r\n      };\r\n      setSize();\r\n      const ro = new ResizeObserver(setSize);\r\n      ro.observe(container);\r\n      const randomFloat = (): number => {\r\n        if (typeof window !== 'undefined' && window.crypto?.getRandomValues) {\r\n          const u32 = new Uint32Array(1);\r\n          window.crypto.getRandomValues(u32);\r\n          return u32[0] / 0xffffffff;\r\n        }\r\n        return Math.random();\r\n      };\r\n      const timeOffset = randomFloat() * 1000;\r\n      let composer: EffectComposer | undefined;\r\n      let touch: ReturnType<typeof createTouchTexture> | undefined;\r\n      let liquidEffect: Effect | undefined;\r\n      if (liquid) {\r\n        touch = createTouchTexture();\r\n        touch.radiusScale = liquidRadius;\r\n        composer = new EffectComposer(renderer);\r\n        const renderPass = new RenderPass(scene, camera);\r\n        liquidEffect = createLiquidEffect(touch.texture, {\r\n          strength: liquidStrength,\r\n          freq: liquidWobbleSpeed\r\n        });\r\n        const effectPass = new EffectPass(camera, liquidEffect);\r\n        effectPass.renderToScreen = true;\r\n        composer.addPass(renderPass);\r\n        composer.addPass(effectPass);\r\n      }\r\n      if (noiseAmount > 0) {\r\n        if (!composer) {\r\n          composer = new EffectComposer(renderer);\r\n          composer.addPass(new RenderPass(scene, camera));\r\n        }\r\n        const noiseEffect = new Effect(\r\n          'NoiseEffect',\r\n          `uniform float uTime; uniform float uAmount; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);} void mainUv(inout vec2 uv){} void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){ float n=hash(floor(uv*vec2(1920.0,1080.0))+floor(uTime*60.0)); float g=(n-0.5)*uAmount; outputColor=inputColor+vec4(vec3(g),0.0);} `,\r\n          {\r\n            uniforms: new Map<string, THREE.Uniform>([\r\n              ['uTime', new THREE.Uniform(0)],\r\n              ['uAmount', new THREE.Uniform(noiseAmount)]\r\n            ])\r\n          }\r\n        );\r\n        const noisePass = new EffectPass(camera, noiseEffect);\r\n        noisePass.renderToScreen = true;\r\n        if (composer && composer.passes.length > 0) {\r\n          composer.passes.forEach(p => {\r\n            const pass = p as { renderToScreen?: boolean };\r\n            pass.renderToScreen = false;\r\n          });\r\n        }\r\n        composer.addPass(noisePass);\r\n      }\r\n      if (composer) composer.setSize(renderer.domElement.width, renderer.domElement.height);\r\n      const mapToPixels = (e: PointerEvent) => {\r\n        const rect = renderer.domElement.getBoundingClientRect();\r\n        const scaleX = renderer.domElement.width / rect.width;\r\n        const scaleY = renderer.domElement.height / rect.height;\r\n        const fx = (e.clientX - rect.left) * scaleX;\r\n        const fy = (rect.height - (e.clientY - rect.top)) * scaleY;\r\n        return {\r\n          fx,\r\n          fy,\r\n          w: renderer.domElement.width,\r\n          h: renderer.domElement.height\r\n        };\r\n      };\r\n      const onPointerDown = (e: PointerEvent) => {\r\n        const { fx, fy } = mapToPixels(e);\r\n        const ix = threeRef.current?.clickIx ?? 0;\r\n        uniforms.uClickPos.value[ix].set(fx, fy);\r\n        uniforms.uClickTimes.value[ix] = uniforms.uTime.value;\r\n        if (threeRef.current) threeRef.current.clickIx = (ix + 1) % MAX_CLICKS;\r\n      };\r\n      const onPointerMove = (e: PointerEvent) => {\r\n        if (!touch) return;\r\n        const { fx, fy, w, h } = mapToPixels(e);\r\n        touch.addTouch({ x: fx / w, y: fy / h });\r\n      };\r\n      renderer.domElement.addEventListener('pointerdown', onPointerDown, {\r\n        passive: true\r\n      });\r\n      renderer.domElement.addEventListener('pointermove', onPointerMove, {\r\n        passive: true\r\n      });\r\n      let raf = 0;\r\n      const animate = () => {\r\n        if (autoPauseOffscreen && !visibilityRef.current.visible) {\r\n          raf = requestAnimationFrame(animate);\r\n          return;\r\n        }\r\n        uniforms.uTime.value = timeOffset + clock.getElapsedTime() * speedRef.current;\r\n        if (liquidEffect) {\r\n          const liqEffect = liquidEffect as Effect & { uniforms: Map<string, THREE.Uniform> };\r\n          const timeUniform = liqEffect.uniforms.get('uTime');\r\n          if (timeUniform) timeUniform.value = uniforms.uTime.value;\r\n        }\r\n        if (composer) {\r\n          if (touch) touch.update();\r\n          composer.passes.forEach(p => {\r\n            const pass = p as { effects?: Array<Effect & { uniforms: Map<string, THREE.Uniform> }> };\r\n            if (pass.effects) {\r\n              pass.effects.forEach(eff => {\r\n                const timeUniform = eff.uniforms?.get('uTime');\r\n                if (timeUniform) timeUniform.value = uniforms.uTime.value;\r\n              });\r\n            }\r\n          });\r\n          composer.render();\r\n        } else renderer.render(scene, camera);\r\n        raf = requestAnimationFrame(animate);\r\n      };\r\n      raf = requestAnimationFrame(animate);\r\n      threeRef.current = {\r\n        renderer,\r\n        scene,\r\n        camera,\r\n        material,\r\n        clock,\r\n        clickIx: 0,\r\n        uniforms,\r\n        resizeObserver: ro,\r\n        raf,\r\n        quad,\r\n        timeOffset,\r\n        composer,\r\n        touch,\r\n        liquidEffect\r\n      };\r\n    } else {\r\n      const t = threeRef.current!;\r\n      t.uniforms.uShapeType.value = SHAPE_MAP[variant] ?? 0;\r\n      t.uniforms.uPixelSize.value = pixelSize * t.renderer.getPixelRatio();\r\n      t.uniforms.uColor.value.set(color);\r\n      t.uniforms.uScale.value = patternScale;\r\n      t.uniforms.uDensity.value = patternDensity;\r\n      t.uniforms.uPixelJitter.value = pixelSizeJitter;\r\n      t.uniforms.uEnableRipples.value = enableRipples ? 1 : 0;\r\n      t.uniforms.uRippleIntensity.value = rippleIntensityScale;\r\n      t.uniforms.uRippleThickness.value = rippleThickness;\r\n      t.uniforms.uRippleSpeed.value = rippleSpeed;\r\n      t.uniforms.uEdgeFade.value = edgeFade;\r\n      if (transparent) t.renderer.setClearAlpha(0);\r\n      else t.renderer.setClearColor(0x000000, 1);\r\n      if (t.liquidEffect) {\r\n        const liqEffect = t.liquidEffect as Effect & { uniforms: Map<string, THREE.Uniform> };\r\n        const uStrength = liqEffect.uniforms.get('uStrength');\r\n        if (uStrength) uStrength.value = liquidStrength;\r\n        const uFreq = liqEffect.uniforms.get('uFreq');\r\n        if (uFreq) uFreq.value = liquidWobbleSpeed;\r\n      }\r\n      if (t.touch) t.touch.radiusScale = liquidRadius;\r\n    }\r\n    prevConfigRef.current = cfg;\r\n    return () => {\r\n      if (threeRef.current && mustReinit) return;\r\n      if (!threeRef.current) return;\r\n      const t = threeRef.current;\r\n      t.resizeObserver?.disconnect();\r\n      cancelAnimationFrame(t.raf!);\r\n      t.quad?.geometry.dispose();\r\n      t.material.dispose();\r\n      t.composer?.dispose();\r\n      t.renderer.dispose();\r\n      if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\r\n      threeRef.current = null;\r\n    };\r\n  }, [\r\n    antialias,\r\n    liquid,\r\n    noiseAmount,\r\n    pixelSize,\r\n    patternScale,\r\n    patternDensity,\r\n    enableRipples,\r\n    rippleIntensityScale,\r\n    rippleThickness,\r\n    rippleSpeed,\r\n    pixelSizeJitter,\r\n    edgeFade,\r\n    transparent,\r\n    liquidStrength,\r\n    liquidRadius,\r\n    liquidWobbleSpeed,\r\n    autoPauseOffscreen,\r\n    variant,\r\n    color,\r\n    speed\r\n  ]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`pixel-blast-container ${className ?? ''}`}\r\n      style={style}\r\n      aria-label=\"PixelBlast interactive background\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default PixelBlast;\r\n"],"mappings":"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,CAACiF,OAAO,CAAC,CAAC,CAAC,CAAC,EAC/B,CAAC,OAAO,EAAE,IAAIjF,KAAK,CAACiF,OAAO,EAAAJ,UAAA,GAACF,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEQ,IAAI,cAAAN,UAAA,cAAAA,UAAA,GAAI,GAAG,CAAC,CAAC,CAChD;EACH,CAAC,CAAC;AACJ,CAAC;AAED,MAAMO,SAA4C,GAAG;EACnDC,MAAM,EAAE,CAAC;EACTC,MAAM,EAAE,CAAC;EACTC,QAAQ,EAAE,CAAC;EACXC,OAAO,EAAE;AACX,CAAC;AAED,MAAMC,UAAU,GAAG;AACnB;AACA;AACA;AACA,CAAC;AAED,MAAMC,YAAY,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,UAAU,GAAG,E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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}